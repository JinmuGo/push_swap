# push\_swap

> Sorting a stack with the fewest possible operations.

https://github.com/user-attachments/assets/3a9b4a3f-3c76-4d60-8c0c-f14a94a4ad09

## 📌 Overview

`push_swap` is a 42 Cursus algorithm project focused on sorting a list of integers using two stacks (`a` and `b`) and a limited set of operations. The goal is to output the most efficient sequence of instructions to sort the stack in ascending order.

This project trains your skills in algorithm optimization, data structures (especially **stacks**), and writing clean, efficient C code.

---

## 📜 Allowed Instructions

* `sa` : Swap the top two elements of stack a
* `sb` : Swap the top two elements of stack b
* `ss` : Perform `sa` and `sb` simultaneously
* `pa` : Push the top element of stack b onto stack a
* `pb` : Push the top element of stack a onto stack b
* `ra` : Rotate stack a (top element becomes bottom)
* `rb` : Rotate stack b
* `rr` : Perform `ra` and `rb` simultaneously
* `rra`: Reverse rotate stack a (bottom element becomes top)
* `rrb`: Reverse rotate stack b
* `rrr`: Perform `rra` and `rrb` simultaneously

---

## ⚙️ Usage

```bash
make             # build push_swap
make bonus       # compile the checker (bonus)
seq [number] | sort -R | xargs ./push_swap
```

### Example

```bash
./push_swap 3 2 1
sa
rra
```

You can validate the output with the optional `checker_bonus`:

```bash
./push_swap 3 2 1 | ./checker_bonus 3 2 1
OK
```

## 🎁 Bonus

A bonus target is provided in the Makefile to build the checker executable:

make bonus

Use the checker to confirm that the operations generated by push_swap correctly sort the stack. It outputs OK if the stack is sorted, or KO otherwise.

## 🧠 Algorithm Strategy

### Small Input Strategy (≤5 elements)

For very small lists, `push_swap` uses the `sort_small` routine, which delegates to specialized handlers:

* **2 elements**: Single `sa` if out of order.
* **3 elements**: Six-case permutation handling with minimal hardcoded swaps and rotations.
* **4–5 elements**: Push the smallest values to stack B, sort the remaining 3 in stack A, then push back from B to A.

> *This is like solving a tiny puzzle by enumerating all possible states and applying the optimal move.*

### Large Input Strategy (>5 elements)

For larger lists, `push_swap` employs a chunk-based greedy algorithm.

1. **Partition Phase (`init_a_to_b`)**

   * Map all values to indices `0..n-1` for consistent comparisons.
   * Divide the indexed range into 6 chunks.
   * For each chunk defined by `[sidx, midx)`, scan stack A:

     * If an element’s `idx` is in the current chunk, `pb` (push to B).
     * Otherwise, `ra` (rotate A) to cycle through.
2. **Merge Phase (`b_to_a`)**

   * While stack B is not empty:

     * Use `find_best_case` to evaluate, for each element in B:

       * **`a_to_right_place`**: rotations needed in A to insert in order.
       * **`b_to_edge`**: rotations needed in B to bring the element to top.
       * **Total moves** = sum of both rotations.
     * Choose the element with minimal total moves.
     * Execute combined or separate rotations (`rotate_stack_ab`).
     * `pa` to move it back to A.
   * Finally, `align_stack_a` rotates A so the smallest element (`idx 0`) is on top.

> *This mimics sorting by pulling out manageable subgroups (chunks), then greedily reassembling them in the optimal sequence.*

---

## 📁 Project Structure

```text
push_swap/
├── src/            # Source files
├── lib/            # Custom utility library
├── includes/       # Header files
├── Makefile        # Build rules
└── README.md       # Project documentation
```

---

## 🛠 Development Info

* **Language**: C (C99 standard)
* **Compilation**: `Makefile` provided
* **Dependencies**: Only the custom **libft** library
* **Index Mapping**: Original values are converted to 0..n-1 indices for uniform comparisons

---

## ✅ Evaluation

* **Correctness**: Proper sorting for all valid inputs
* **Efficiency**: Minimal number of operations
* **Memory**: No leaks or invalid accesses
* **Code Quality**: Readability, modularity, and adherence to 42 coding standards
